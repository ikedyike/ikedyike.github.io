<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Orbiting Cards</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Ubuntu+Mono:wght@300;400;700&display=swap" rel="stylesheet">

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: black;
      min-height: 100vh;
      overflow: hidden;
      color: #fff;
      font-family: 'Ubuntu Mono', monospace;
    }

    /* Home button (back to three-js hub) */
    .home-btn {
      position: fixed;
      top: 2%;
      left: 2%;
      z-index: 10;

      font-size: 3em;
      line-height: 1;

      background: rgba(0,0,0,0.85);
      border: none;
      padding: 0.1em 0.2em;
      border-radius: 6px;

      color: #fff;
      text-decoration: none;
      cursor: pointer;
      user-select: none;

      transition: transform 120ms ease, opacity 120ms ease;
    }
    .home-btn:hover,
    .home-btn:active { transform: scale(1.06); opacity: 0.9; }

    /* Readable text strips (no border) */
    .title, .hint {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;

      background: rgba(0,0,0,0.85);
      border-radius: 10px;
      padding: 0.55rem 0.9rem;
      text-align: center;
      max-width: 92vw;
    }

    .title {
      top: 6%;
      font-weight: 300;
      letter-spacing: 0.10em;
      font-size: clamp(1.1rem, 3vw, 2rem);
      opacity: 0.95;
    }

    .hint {
      bottom: 6%;
      font-size: clamp(0.9rem, 1.6vw, 1.05rem);
      opacity: 0.75;
    }
	
	i.rain-drop {
	  position: absolute;
	  height: 200px;
	  background: linear-gradient(transparent, #FFF);
	  border-bottom-left-radius: 5px;
	  border-bottom-right-radius: 5px;
	  animation: animate 5s linear infinite;
	  pointer-events: none;
	  z-index: 0;
	}
	
	@keyframes animate {
      0%   { transform: translateY(-200px); }
      100% { transform: translateY(calc(100vh + 200px)); }
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>

<body>
  <!-- back to three-js hub -->
  <a class="home-btn" href="../index.html" title="Back to Three.js">←</a>

  <div class="title">Orbiting Cards</div>
  <div class="hint">LowkeyMon card art (drag to rotate)</div>
  
  <script src="../../rain.js"></script>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

  // ----- CONFIG: put your PNGs in ./cards/ -----
  const cardFiles = [
    "cards/card1.png",
    "cards/card2.png",
    "cards/card3.png",
    "cards/card4.png",
    "cards/card5.png",
    "cards/card6.png",
    "cards/card7.png",
    "cards/card8.png",
    "cards/card9.png",
  ];

  function isMobile() {
    return window.innerWidth <= 480;
  }

  // "Uniform card frame" aspect (width/height)
  // Pokemon-ish cards are ~ 2.5x3.5 => 0.714
  const CARD_ASPECT = 0.714;

  function coverCropTexture(texture, frameAspect) {
    const img = texture.image;
    if (!img || !img.width || !img.height) return;

    const imgAspect = img.width / img.height;

    texture.center.set(0.5, 0.5);
    texture.rotation = 0;

    if (imgAspect > frameAspect) {
      // image is wider -> crop left/right
      const scaleX = frameAspect / imgAspect;
      texture.repeat.set(scaleX, 1);
      texture.offset.set((1 - scaleX) / 2, 0);
    } else {
      // image is taller -> crop top/bottom
      const scaleY = imgAspect / frameAspect;
      texture.repeat.set(1, scaleY);
      texture.offset.set(0, (1 - scaleY) / 2);
    }

    texture.needsUpdate = true;
  }

  // ----- Scene -----
  const scene = new THREE.Scene();
  
  scene.fog = new THREE.Fog(0x000000, isMobile() ? 5.5 : 7.0, isMobile() ? 12 : 16);

	const fov = isMobile() ? 60 : 45; // stronger perspective on mobile
	const camera = new THREE.PerspectiveCamera(
	  fov,
	  window.innerWidth / window.innerHeight,
	  0.1,
	  200
	);
	camera.position.set(0, isMobile() ? 0.25 : 0.35, isMobile() ? 6.1 : 7.0);
	camera.lookAt(0, 0, 0);

  // Renderer (opaque black => rain behind won't show even if rain.js exists)
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x000000, 1);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  document.body.appendChild(renderer.domElement);

  // Cards don’t need lighting when using MeshBasicMaterial, but ambient is harmless.
  scene.add(new THREE.AmbientLight(0xffffff, 1.0));

  // Group to spin
  const ring = new THREE.Group();
  scene.add(ring);
  
  ring.rotation.x = isMobile() ? -0.22 : -0.14; // tilt toward camera => depth

  // Load textures
  const loader = new THREE.TextureLoader();
  const textures = await Promise.all(
    cardFiles.map(
      (src) =>
        new Promise((resolve) => {
          loader.load(
            src,
            (tex) => {
              tex.colorSpace = THREE.SRGBColorSpace;
              tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
              resolve(tex);
            },
            undefined,
            (err) => {
              console.warn("Failed to load:", src, err);
              resolve(null); // keep going even if one fails
            }
          );
        })
    )
  );

  const validTextures = textures.filter(Boolean);

  // ----- UNIFORM SIZE (same geometry for every card) -----
  const CARD_H = isMobile() ? 1.15 : 2.05;           // smaller on mobile
  const CARD_W = CARD_H * CARD_ASPECT;

  // tighter orbit
  const RADIUS = isMobile() ? 1.55 : 3.25;

  const cards = [];
  const geom = new THREE.PlaneGeometry(CARD_W, CARD_H);

  validTextures.forEach((tex, i) => {
    // cover-crop each texture into the uniform frame
    coverCropTexture(tex, CARD_W / CARD_H);

    const mat = new THREE.MeshBasicMaterial({
      map: tex,
      transparent: true,
      side: THREE.DoubleSide,
    });

    const mesh = new THREE.Mesh(geom, mat);

    // Position on ring
    const count = validTextures.length;
    const angle = (i / count) * Math.PI * 2;

    mesh.position.set(
      Math.cos(angle) * RADIUS,
      0,
      Math.sin(angle) * RADIUS
    );

    ring.add(mesh);
    cards.push(mesh);
  });

  // ----- Interaction: drag to rotate (mouse + touch) -----
  let isDown = false;
  let lastX = 0;
  let dragVelocity = 0;
  let targetSpin = 0;

  function onDown(clientX) {
    isDown = true;
    lastX = clientX;
    dragVelocity = 0;
  }

  function onMove(clientX) {
    if (!isDown) return;
    const dx = clientX - lastX;
    lastX = clientX;

    const delta = dx * 0.0035; // slightly slower than before
    targetSpin += delta;
    dragVelocity = delta;
  }

  function onUp() {
    isDown = false;
  }

  window.addEventListener("mousedown", (e) => onDown(e.clientX));
  window.addEventListener("mousemove", (e) => onMove(e.clientX));
  window.addEventListener("mouseup", onUp);

  window.addEventListener(
    "touchstart",
    (e) => {
      if (e.touches.length > 0) onDown(e.touches[0].clientX);
    },
    { passive: true }
  );

  window.addEventListener(
    "touchmove",
    (e) => {
      if (e.touches.length > 0) onMove(e.touches[0].clientX);
    },
    { passive: true }
  );

  window.addEventListener("touchend", onUp);

  // ----- Animation -----
  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);
    const t = clock.getElapsedTime();

    const idle = isDown ? 0 : (isMobile() ? 0.0012 : 0.0018);

    // inertia
    if (!isDown) {
      targetSpin += dragVelocity;
      dragVelocity *= 0.92;
    }

    ring.rotation.y += idle + targetSpin;
    targetSpin *= 0.85;

    // Keep cards readable: face camera + tiny bob
    const bob = isMobile() ? 0.05 : 0.10;
	cards.forEach((mesh, idx) => {
	  mesh.position.y = Math.sin(t * 1.2 + idx * 0.6) * bob;

	  // Face camera
	  mesh.lookAt(camera.position);
	  mesh.rotateY(Math.PI);

	  // --- DEPTH CUES (money part) ---
	  // distance from camera (bigger = farther)
	  const d = mesh.getWorldPosition(new THREE.Vector3()).distanceTo(camera.position);

	  // map distance to 0..1 (near..far)
	  const nearD = isMobile() ? 4.5 : 5.2;
	  const farD  = isMobile() ? 9.0 : 11.0;
	  const depth01 = THREE.MathUtils.clamp((d - nearD) / (farD - nearD), 0, 1);

	  // farther = slightly smaller
	  const s = THREE.MathUtils.lerp(1.0, 0.82, depth01);
	  mesh.scale.set(s, s, s);

	  // farther = slightly dimmer
	  if (mesh.material) {
		mesh.material.opacity = THREE.MathUtils.lerp(1.0, 0.65, depth01);
		mesh.material.transparent = true;
	  }
	});

    renderer.render(scene, camera);
  }
  animate();

  // ----- Resize -----
  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  });
</script>
</body>
</html>
